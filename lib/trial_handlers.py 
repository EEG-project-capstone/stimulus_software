# lib/trial_handlers.py

"""
Modular trial handlers for different stimulus types.
Each handler encapsulates the logic for a specific trial type.
"""

import random
import numpy as np
import logging
from abc import ABC, abstractmethod

logger = logging.getLogger('eeg_stimulus.trial_handlers')


class TrialHandler(ABC):
    """Abstract base class for trial handlers."""
    
    def __init__(self, auditory_stimulator):
        self.audio_stim = auditory_stimulator
        self.state = {}
    
    @abstractmethod
    def start(self, trial: dict):
        """Start the trial."""
        pass
    
    @abstractmethod
    def continue_trial(self):
        """Continue the trial (for multi-phase trials)."""
        pass
    
    def reset(self):
        """Reset handler state."""
        self.state = {}


class LanguageTrialHandler(TrialHandler):
    """Handler for language trials."""
    
    def start(self, trial: dict):
        """Start a language trial."""
        n = trial.get('audio_index', 0)
        logger.debug(f"Starting language trial with audio index {n}")
        
        if 0 <= n < len(self.audio_stim.trials.lang_audio):
            audio_segment = self.audio_stim.trials.lang_audio[n]
            samples = np.array(audio_segment.get_array_of_samples(), dtype=np.int16)
            
            if audio_segment.channels == 2:
                samples = samples.reshape(-1, 2)
            else:
                samples = samples.reshape(-1, 1)
            
            # Log metadata
            self.audio_stim._log_event('language_trial_meta', {
                'audio_index': n,
                'sentence_ids': self.audio_stim.trials.lang_trials_ids[n] if n < len(self.audio_stim.trials.lang_trials_ids) else None,
                'duration_sec': len(samples) / audio_segment.frame_rate
            })
            
            self.audio_stim.play_audio(
                samples=samples,
                sample_rate=audio_segment.frame_rate,
                callback=self.audio_stim.finish_current_trial,
                log_label="language_audio"
            )
        else:
            logger.error(f"Invalid language audio index: {n}")
            self.audio_stim.finish_current_trial()
    
    def continue_trial(self):
        """Language trials don't have continuation logic."""
        pass


class CommandTrialHandler(TrialHandler):
    """Handler for motor command trials."""
    
    TOTAL_CYCLES = 8
    KEEP_PAUSE_MS = 10000
    STOP_PAUSE_MS = 10000
    PROMPT_DELAY_MS = 2000
    
    def start(self, trial: dict):
        """Start a command trial."""
        trial_type = trial.get('type', '')
        self.state['side'] = 'right' if 'right' in trial_type else 'left'
        self.state['has_prompt'] = '+p' in trial_type
        self.state['cycle'] = 0
        self.state['phase'] = 'keep'
        
        logger.info(f"Starting {self.state['side']} command trial (prompt={self.state['has_prompt']})")
        self.audio_stim._log_event('command_trial_start', {
            'side': self.state['side'],
            'prompt': self.state['has_prompt']
        })
        
        if self.state['has_prompt']:
            self._play_prompt()
        else:
            self.continue_trial()
    
    def _play_prompt(self):
        """Play the motor command prompt."""
        prompt_seg = self.audio_stim.trials.motor_prompt_audio
        samples = np.array(prompt_seg.get_array_of_samples(), dtype=np.int16)
        
        if prompt_seg.channels == 2:
            samples = samples.reshape(-1, 2)
        else:
            samples = samples.reshape(-1, 1)
        
        self.audio_stim.play_audio(
            samples=samples,
            sample_rate=prompt_seg.frame_rate,
            callback=lambda: self.audio_stim._schedule(self.PROMPT_DELAY_MS, self.continue_trial),
            log_label="motor_prompt"
        )
    
    def continue_trial(self):
        """Continue the command trial cycle."""
        if not self._should_continue():
            return
        
        if self.state['cycle'] >= self.TOTAL_CYCLES:
            self._finish_trial()
            return
        
        phase = self.state['phase']
        
        if phase == 'keep':
            self._play_keep_command()
        elif phase == 'pause_after_keep':
            self.audio_stim._schedule(self.KEEP_PAUSE_MS, lambda: self._set_phase('stop'))
        elif phase == 'stop':
            self._play_stop_command()
        elif phase == 'pause_after_stop':
            self.audio_stim._schedule(self.STOP_PAUSE_MS, self._next_cycle)
    
    def _should_continue(self) -> bool:
        """Check if trial should continue."""
        if self.audio_stim.gui_callback.playback_state != "playing" or self.audio_stim.is_paused:
            self.audio_stim._schedule(100, self.continue_trial)
            return False
        return True
    
    def _play_keep_command(self):
        """Play the 'keep' command audio."""
        logger.debug(f"Command trial cycle {self.state['cycle'] + 1}/{self.TOTAL_CYCLES}: KEEP phase")
        self.audio_stim._log_event('command_cycle', {
            'cycle': self.state['cycle'] + 1,
            'phase': 'keep',
            'side': self.state['side']
        })
        
        audio = (self.audio_stim.trials.right_keep_audio if self.state['side'] == 'right'
                else self.audio_stim.trials.left_keep_audio)
        
        samples = np.array(audio.get_array_of_samples(), dtype=np.int16).reshape(-1, 1)
        self.audio_stim.play_audio(
            samples=samples,
            sample_rate=audio.frame_rate,
            callback=lambda: self._set_phase('pause_after_keep'),
            log_label=f"{self.state['side']}_keep"
        )
    
    def _play_stop_command(self):
        """Play the 'stop' command audio."""
        logger.debug(f"Command trial cycle {self.state['cycle'] + 1}/{self.TOTAL_CYCLES}: STOP phase")
        self.audio_stim._log_event('command_cycle', {
            'cycle': self.state['cycle'] + 1,
            'phase': 'stop',
            'side': self.state['side']
        })
        
        audio = (self.audio_stim.trials.right_stop_audio if self.state['side'] == 'right'
                else self.audio_stim.trials.left_stop_audio)
        
        samples = np.array(audio.get_array_of_samples(), dtype=np.int16).reshape(-1, 1)
        self.audio_stim.play_audio(
            samples=samples,
            sample_rate=audio.frame_rate,
            callback=lambda: self._set_phase('pause_after_stop'),
            log_label=f"{self.state['side']}_stop"
        )
    
    def _set_phase(self, phase: str):
        """Set the current phase and continue."""
        self.state['phase'] = phase
        self.continue_trial()
    
    def _next_cycle(self):
        """Move to the next cycle."""
        self.state['cycle'] += 1
        self.state['phase'] = 'keep'
        self.continue_trial()
    
    def _finish_trial(self):
        """Finish the command trial."""
        logger.debug(f"Command trial completed: {self.state['side']}, {self.TOTAL_CYCLES} cycles")
        self.audio_stim._log_event('command_trial_end', {
            'side': self.state['side'],
            'total_cycles': self.TOTAL_CYCLES
        })
        self.audio_stim.finish_current_trial()


class OddballTrialHandler(TrialHandler):
    """Handler for oddball trials."""
    
    INITIAL_TONES = 5
    MAIN_TONES = 20
    TONE_DURATION_MS = 100
    INTER_TONE_INTERVAL_MS = 900
    STANDARD_FREQ = 1000
    RARE_FREQ = 2000
    RARE_PROBABILITY = 0.2
    PROMPT_DELAY_MS = 2000
    
    def start(self, trial: dict):
        """Start an oddball trial."""
        trial_type = trial.get('type', '')
        self.state['has_prompt'] = '+p' in trial_type
        self.state['tone_count'] = 0
        self.state['phase'] = 'initial_standard'
        
        logger.info(f"Starting oddball trial (prompt={self.state['has_prompt']})")
        self.audio_stim._log_event('oddball_trial_start', {'prompt': self.state['has_prompt']})
        
        if self.state['has_prompt']:
            self._play_prompt()
        else:
            self.continue_trial()
    
    def _play_prompt(self):
        """Play the oddball prompt."""
        prompt_seg = self.audio_stim.trials.oddball_prompt_audio
        samples = np.array(prompt_seg.get_array_of_samples(), dtype=np.int16)
        
        if prompt_seg.channels == 2:
            samples = samples.reshape(-1, 2)
        else:
            samples = samples.reshape(-1, 1)
        
        self.audio_stim.play_audio(
            samples=samples,
            sample_rate=prompt_seg.frame_rate,
            callback=lambda: self.audio_stim._schedule(self.PROMPT_DELAY_MS, self.continue_trial),
            log_label="oddball_prompt"
        )
    
    def continue_trial(self):
        """Continue the oddball trial."""
        if not self._should_continue():
            return
        
        phase = self.state['phase']
        
        if phase == 'initial_standard':
            self._handle_initial_phase()
        elif phase == 'main_sequence':
            self._handle_main_phase()
    
    def _should_continue(self) -> bool:
        """Check if trial should continue."""
        if self.audio_stim.gui_callback.playback_state != "playing" or self.audio_stim.is_paused:
            self.audio_stim._schedule(100, self.continue_trial)
            return False
        return True
    
    def _handle_initial_phase(self):
        """Handle the initial standard tones phase."""
        if self.state['tone_count'] < self.INITIAL_TONES:
            self.state['tone_count'] += 1
            logger.debug(f"Oddball initial tone {self.state['tone_count']}/{self.INITIAL_TONES}")
            
            self._play_tone(self.STANDARD_FREQ, 'standard_tone')
        else:
            logger.debug("Oddball switching to main sequence")
            self.audio_stim._log_event('oddball_phase_change', {
                'from': 'initial_standard',
                'to': 'main_sequence'
            })
            self.state['phase'] = 'main_sequence'
            self.state['tone_count'] = 0
            self.continue_trial()
    
    def _handle_main_phase(self):
        """Handle the main sequence phase with rare tones."""
        if self.state['tone_count'] < self.MAIN_TONES:
            self.state['tone_count'] += 1
            
            is_rare = random.random() < self.RARE_PROBABILITY
            frequency = self.RARE_FREQ if is_rare else self.STANDARD_FREQ
            label = "rare_tone" if is_rare else "standard_tone"
            
            logger.debug(f"Oddball main tone {self.state['tone_count']}/{self.MAIN_TONES}: {label}")
            
            self._play_tone(frequency, label)
        else:
            self._finish_trial()
    
    def _play_tone(self, frequency: int, label: str):
        """Play a single tone."""
        tone_samples = self.audio_stim._generate_tone(frequency, self.TONE_DURATION_MS)
        self.audio_stim.play_audio(
            samples=tone_samples,
            sample_rate=44100,
            callback=lambda: self.audio_stim._schedule(self.INTER_TONE_INTERVAL_MS, self.continue_trial),
            log_label=label
        )
    
    def _finish_trial(self):
        """Finish the oddball trial."""
        logger.debug("Oddball trial sequence completed")
        self.audio_stim._log_event('oddball_trial_end', {
            'total_tones': self.INITIAL_TONES + self.MAIN_TONES
        })
        self.audio_stim.finish_current_trial()


class VoiceTrialHandler(TrialHandler):
    """Handler for voice trials (control and loved one)."""
    
    def start(self, trial: dict):
        """Start a voice trial."""
        voice_type = trial.get('voice_type', 'control')
        logger.info(f"Starting {voice_type} voice trial")
        self.audio_stim._log_event('voice_trial_start', {'voice_type': voice_type})
        
        audio_data = (self.audio_stim.trials.control_voice_audio if voice_type == "control"
                     else self.audio_stim.trials.loved_one_voice_audio)
        
        if audio_data is None:
            logger.error(f"{voice_type} audio data is None, skipping trial")
            self.audio_stim.finish_current_trial()
            return
        
        # Ensure int16 format
        if audio_data.dtype != np.int16:
            logger.warning(f"{voice_type} audio has dtype {audio_data.dtype}, converting...")
            if np.issubdtype(audio_data.dtype, np.floating):
                audio_data = (audio_data * 32767).astype(np.int16)
            else:
                audio_data = audio_data.astype(np.int16)
        
        self.audio_stim._log_event('voice_trial_meta', {
            'voice_type': voice_type,
            'duration_sec': len(audio_data) / self.audio_stim.trials.sample_rate,
            'shape': audio_data.shape
        })
        
        self.audio_stim.play_audio(
            samples=audio_data,
            sample_rate=self.audio_stim.trials.sample_rate,
            callback=self.audio_stim.finish_current_trial,
            log_label=f"{voice_type}_voice"
        )
    
    def continue_trial(self):
        """Voice trials don't have continuation logic."""
        pass